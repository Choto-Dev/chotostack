import fs from "node:fs/promises";
import path from "node:path";
import { fileURLToPath } from "node:url";
import { consola } from "consola";
import { Project } from "ts-morph";

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

const ROOT = path.join(__dirname, "../../../../choto-templates/templates");
const OUTPUT = path.join(__dirname, "../src/utils/templates.ts");

async function collectTemplateNamespace(
  templateDir: string,
  templatesNamespace: string[] = [],
  prefix = ""
): Promise<string[]> {
  const items = await fs.readdir(templateDir);

  for (const item of items) {
    const itemPath = path.join(templateDir, item);
    const itemStat = await fs.stat(itemPath);
    const templatePrefix = prefix ? `${prefix}/${item}` : item;

    if (itemStat.isDirectory()) {
      if (await isTemplate(itemPath)) {
        templatesNamespace.push(templatePrefix);
      } else {
        await collectTemplateNamespace(
          itemPath,
          templatesNamespace,
          templatePrefix
        );
      }
    }
  }

  return templatesNamespace;
}

async function isTemplate(templatePath: string): Promise<boolean> {
  const expectedArray = ["files", "meta", "README.md"];
  const templateItems = await fs.readdir(templatePath);

  return (
    templateItems.length === expectedArray.length &&
    templateItems.every((item) => expectedArray.includes(item))
  );
}

const templatePaths = await collectTemplateNamespace(ROOT);

const project = new Project();
const file = project.createSourceFile(OUTPUT, "", { overwrite: true });

file.addTypeAlias({
  isExported: true,
  name: "TTemplatePath",
  type: templatePaths.map((p) => JSON.stringify(p)).join(" | "),
  docs: ["Auto-generated by scripts/generate-tempate-types.ts"],
});

project
  .save()
  .then(() =>
    consola.success(
      `Generated templates.ts with ${templatePaths.length} entries`
    )
  )
  .catch((error) => {
    consola.error(error);
  });
